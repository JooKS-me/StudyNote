![image-20210226120011987](https://img.jooks.cn/img/20210226120012.png)

## 内存参数设置

#### 堆内存(Heap)

- 共享，内存大户，存储所有的对象和数组
- -Xms初始堆值，-Xmx最大堆值

#### 栈内存(JVM Stack)

- 线程私有，存储类中每个方法的内容
- -Xss 最大栈值

#### 方法区(Method Area)

- 存储类信息、常量池等
- 1.7及以前，永久区(Perm)，-XX:PermSize，-XX:MaxPermSize
- 1.8及以后，元数据区(Metadata)，-XX:MetaspaceSize，-XX:MaxMetaspaceSize

## 垃圾回收

#### 垃圾收集器

JVM有内置的垃圾收集器

- GC, Garbage Collector
- 自动清除无用的对象，回收内存

垃圾收集器的工作职责(John McCarthy, Lisp语言)

- 什么内存需要收集（判定无用的对象）
- 什么时候回收（何时启动，不影响程序正常运行）
- 如何回收（回收过程，要求速度快、时间短、影响小）

#### Java对象生命周期

- 对象通过构造函数创建，但是没有析构函数回收内存
- 对象默认存活在离它最近的一对大括号中

#### Java程序语言关于内存回收的API

- Object的finalize方法，垃圾收集器在回收对象的时候调用，有且仅被调用一次

  但是这种方法不靠谱，因为你无法预测什么时候会调用这个方法！

- System.gc()方法，运行垃圾收集器

  但是也不靠谱，官方文档说don't call System.gc()，也无法预测什么时候会调用这个方法！

#### 垃圾判断规则

- 基于对象引用判定无用对象
  - 零引用，互引用等

- 对象引用链
  - 通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。

#### Java对象引用

- 强引用
  - 例如Object obj = new Object();  Object obj2 = obj;
  - 只要强引用还在，对象就不会被回收，哪怕发生OOM异常
- 软引用
  - 描述有用但非必需的对象
  - 在系统将要发生内存溢出异常之前，会把这些对象列为可回收
  - JDK提供了SoftReference类来实现软引用
- 弱引用
  - 描述非必需对象，比软引用强度更弱些
  - 被弱引用关联的对象只能生存到下一次垃圾收集发生之前
  - JDK提供了WeakReferen类来实现弱引用
- 虚引用
  - 最弱的引用关系，随时都可能被回收
  - 虚引用的唯一目的是能在这个对象被回收时收到一个系统通知，用于对象回收跟踪
  - JDK提供了PhantomReference类来实现虚引用

软引用和弱引用，适合用来保存可有可无的缓存数据。

## 垃圾收集算法

#### 引用计数法

- 一种古老的算法
- 每个对象都有一个计数器
- 有引用，计数器加一，当引用失效，计数器减一
- 计数器为0的对象，将被回收
- 优点：简单，效率高
- 缺点：无法识别对象之间的互相循环引用

#### 标记-清除算法

- 标记阶段：标记出所有需要回收的对象，比如可以根据引用计数法标记

- 回收阶段：统一回收所有被标记的对象

- 优点：简单

- 缺点：效率不高，会产生内存碎片，如图。

  ![image-20210226155605814](https://img.jooks.cn/img/20210226155605.png)

#### 复制算法

- 将可用的内存按容量划分为大小相等的两块，每次只使用其中一块。

- 当这一块内存用完，就将还存活着的对象复制到另一块上面

- 然后把已使用过的内存空间一次清理掉

- 优点：简单、高效

- 缺点：可用内存减小、对象存活率高时复制较多。

  ![image-20210226160211264](https://img.jooks.cn/img/20210226160211.png)

#### 标记-整理算法

- 标记阶段：与“标记-清楚“算法一样

- 整理阶段：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

- 优点：避免内存碎片产生，无需两块相同内存

- 缺点：计算代价大，标记清除+碎片整理，需要更新引用地址

   ![image-20210226162216902](https://img.jooks.cn/img/20210226162216.png)

## 分代收集

- Java对象的生命周期不用，有长有短
- 根据对象存活周期，将内存划分为新生代和老年代
- 新生代（Young Generation）
  - 主要存放短暂生命周期的对象
  - 新创建的对象都先放入新生代，大部分新建对象在第一次gc时被回收
- 老年代（Tenured Generation）
  - 一个对象经过几次gc仍然存活，则放入老年代
  - 这些对象可以存活很长时间，或者伴随程序一生，需要常驻内存，可以减少回收次数。

![image-20210226162734732](https://img.jooks.cn/img/20210226162749.png)

**针对新生代，JVM采用复制算法。**

第一次gc时，将Eden Space和Form Space的存活对象复制到To Space中，然后执行清除；第二次gc时，将Eden Space和To Space的存活对象复制到From Space中，然后执行清除；From Space和To Space是等价的。

![image-20210226162840423](https://img.jooks.cn/img/20210226162840.png)

**针对老年代，JVM采用标记清除或标记整理算法**

## 回看堆内存

![image-20210226163857730](https://img.jooks.cn/img/20210226163857.png)

堆内存可以分为三部分：新生代、老年代、元数据区(jdk1.7及以前叫永久区)



