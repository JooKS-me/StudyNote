Redis单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，但Redis的其他功能，如持久化、异步删除、集群数据同步等，其实是额外线程执行的。

## 多线程的坏处

当有多个线程要修改共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。

## Redis单线程为什么那么快？

1. Redis大部分操作都在内存上完成；
2. 它采用了高效的数据结构；
3. 采用多路复用机制

## Redis基本IO模型

![image-20210315151444602](https://img.jooks.cn/img/20210315151444.png)

在阻塞模式下，这里存在两个阻塞点 accept(和客户端建立连接) 和 recv (从 socket 中读取请求) 。

当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。

类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。

## Redis非阻塞模式

Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上。

![image-20210315152001476](https://img.jooks.cn/img/20210315152001.png)

socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。

针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。

类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。

那么这种非阻塞模式是怎么实现的呢？**基于多路复用的高性能 I/O 模型**

## 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理。

![image-20210315152626695](https://img.jooks.cn/img/20210315152626.png)

图中的多个 FD 就是刚才所说的多个套接字。为了在请求到达时能通知到 Redis 线程，select/epoll 提供了**基于事件的回调机制**，即针对不同事件的发生，调用相应的处理函数。

这些事件会被放进一个**事件队列**，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。

> 这个机制的实现有很多种，既有基于 Linux 系统下的 select 和 epoll 实现，也有基于 FreeBSD 的 kqueue 实现，以及基于 Solaris 的 evport 实现。

