## 说一说new在JVM中的流程

当JVM遇到一条字节码new指令时，会先去方法区中的常量池检查是否有对应的类的符号引用，并检查这个类是否已被加载，如果未被加载则执行相应的类加载流程。

类加载检查通过之后，开始分配内存，将Java堆中的一块确定大小的内存分配给对象。分配有两种方式，一种是“指针碰撞”，还有一种是“空闲列表”，使用CMS这类基于清除算法的收集器，只能采用“空闲列表”的方式。分配内存时为了解决线程安全问题，会使用(1)CAS配上重试或者(2)本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)来解决。

分配完内存后，对内存进行置0操作，使得对象还未初始化就能直接使用。

接着设置对象头。

接着设置执行构造方法。

然后一个对象就创建好了。

## 什么是指针碰撞？什么是空闲列表？

对于绝对规整的Java堆，将使用过的内存放在一边，将空闲的内存放在另一边，中间设置一个指针作为分界点的指示器，然后分配内存时将指针向空闲内存一侧移动。这种分配内存的方式就叫做“指针碰撞”。

对于非规整的Java堆，JVM必须维护一个列表，记录哪些内存块时可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。这种分配内存的方式就叫做“空闲列表”。

## 那说一说对象头吧

对象头中包含两类信息。

第一类是存储对象自身的运行数据，如哈希码、GC分代年龄、线程持有的锁等。

另一部分是类型指针，JVM通过这个指针确定该对象是哪个类的对象，指针指向方法区中的对象类型数据。

另外如果是数组的话，还会保存数组的长度。

对象头部被设计成8个字节或16个字节。

## 那对象由哪些部分组成呢？

对象由对象头、实例数据、对齐填充组成。

其中，对齐填充的存在是因为HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说对象大小必须是8字节的整数倍，因此通过对齐填充来调整对象大小。

## 那对象创建好了怎么访问呢？

在Java虚拟机栈中存在局部变量表，局部变量表中存有reference类型的数据，即对象引用。reference类型有两种方式获取到对象。

一种是通过句柄访问，Java堆中有一块内存作为句柄池，句柄包含了对象实例数据的指针和对象类型数据的指针。而reference存储句柄的地址，从而间接访问到对象实例数据和对象类型数据。

还有一种方式是通过直接指针访问，reference直接指向对象的地址，而对象头包含了对象类型数据的指针。从而实现了堆对象实例数据和对象类型数据的访问。这种方式访问对象实例数据时速度更快。





