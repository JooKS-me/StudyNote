## 程序计数器

可以看作是当前线程所执行的字节码的行号指示器。

字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。

为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的是一个Java方法，那计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，那么计数器中的值则应是Undefined。

另外，程序计数器是《Java虚拟机规范》中唯一一个没有规定任何OOM情况的区域。

## Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。

每个java方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个帧栈在虚拟机栈中从入栈到出栈的过程。

**局部变量表**存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和returnAdress类型。这些数据类型的局部变量表中的存储空间以局部变量槽(Slot)来表示，比如64位的long和double会占用两个Slot。局部变量表所需的内存空间是在编译期间完成分配，进入一个方法的时候，局部变量表的大小是完全确定的。

在线程请求的栈深度大于虚拟机栈所允许的深度时，抛出StackOverflowError异常；如果栈空间申请失败，则抛出OutOfMemoryError异常（对于HotSpot这类无法动态拓展的虚拟机）。

## 本地方法栈

为虚拟机使用到的Native方法提供服务。

抛出异常于Java虚拟机栈类似。

HotSpot虚拟机就直接把Java虚拟机栈和本地方法栈和二为一。

## Java堆

被所有线程共享的一块内存区域，在虚拟机启动时创建。

Java几乎所有对象实例都在堆上分配内存。

Java堆是垃圾收集器管理的内存区域。

## 方法区

被所有线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

在JDK8以前，HotSpot使用永久代来实现方法区，将垃圾收集器的分代设计扩展至方法区。而永久代有内存上限，会导致更容易遇到内存溢出的问题。

JDK8完全废弃永久代，改用在本地内存中实现的元空间来实现。

相对而言，垃圾收集在方法区出现较少，主要是针对常量池的回收和类型的卸载。

如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

**运行时常量池**是方法区的一部分，Class文件中有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。但是并非只有编译器才能产生常量，运行期间也可以将新的常量放入池中，如String类的intern()方法。

## 直接内存

直接内存不属于JVM的一部分。

NIO引入了一种基于Channel和Buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，避免Java堆和Native堆中来回复制数据。

但是如果内存申请过多也会造成OOM异常。















