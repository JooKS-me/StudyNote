## 进程的定义

进程是程序的一次执行过程，是进程实体的运行过程，是系统进行 **资源分配** 和 **调度** 的一个独立单位，是 **资源分配** 的基本单位（调度的基本单位是线程）

程序就是一个指令序列，程序的代码放在内存中的 **程序段** 内，程序运行时使用和产生的数据放在 **数据段** 内。

系统为每个运行的程序配置一个数据结构，称为 **进程控制块**（**PCB**），用来描述进程的各种信息（如程序代码的存放位置）。

- PCB中包含了
  - 进程描述信息
    - 进程标识符PID
    - 用户标识符UID
  - 进程控制和管理信息
    - 进程当前状态
    - 进程优先级
  - 资源分配清单
    - 程序段指针
    - 数据段指针
    - 键盘
    - 鼠标
  - 处理器相关信息
    - 各种寄存器值：进程切换是把当前进程运行状态记录到PCB中

PCB、程序段、数据段三部分构成了 **进程实体**（**进程映像**）

创建进程：创建进程实体中的PCB

撤销进程：撤销进程实体中的PCB

## 进程的组织

- 链接方式

  执行指针，指向当前处于运行状态的进程的PCB，只有一个。

  就绪队列指针，指向处于就绪态的进程队列

  阻塞队列，指向处于阻塞态的进程，很多操作系统还会根据阻塞原因大的不同，再分为多个阻塞队列。

- 索引方式

  执行指针，跟上面一样

  就绪表指针，指向就绪索引表，索引表中的各项又指向一个进程PCB

  阻塞表指针，指向阻塞索引表

## 进程的特征

- 动态性

  进程是程序的一次执行过程

- 并发性

  内存中的多个进程实体可以并发执行

- 独立性

  进程是资源分配、接收调度的基本单位

- 异步性

- 结构性

  每个进程都有一个PCB。结构上看，进程由程序段、数据段、PCB组成。

## 进程的状态

创建态，进程正在被创建，系统为进程分配资源，初始化PCB

运行态，占有CPU，并在CPU上运行

就绪态，已经具备运行条件，但由于没有空闲CPU，而暂时不能运行

阻塞态，因等待某一事件而暂时不能运行

终止态，进程正在从系统中撤销，操作系统正在回收资源、撤销PCB

## 进程控制

原语：不可被中断的进程控制指令序列，具有原子性。

首先执行 **关中断** 指令，此后外部中断信号无效，然后执行一系列 **原语代码** ，最后执行 **开中断** 指令，进程可以被正常中断。

关中断、开中断权限非常大，只能在核心态下执行。

**创建原语**：申请空白PCB，为新进程分配资源，初始化PCB，将PCB插入就绪队列。

**撤销原语**：从PCB集合中找到终止的PCB，若程序正在进行，立即剥夺CPU，分配给其他进程，终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统，删除PCB。

**阻塞原语**：找到要阻塞的进程对应的PCB，保护进程线程，将PCB状态信息设置为阻塞态，暂停进程运行，将PCB插入相应事件的等待队列。

**唤醒原语**：在阻塞队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度。

## 进程通信

- 共享存储

  前提：为了保证进程的独立，一个进程不能访问其他进程的内存空间。

  - 基于数据结构的共享

    速度慢、限制多，是一种低级通信方式

  - 基于存储区的共享

    在内存中划一块共享存储区，数据的形式和存放位置都由进程控制（比数据结构共享更加自由），而不是操作系统。两个进程对共享空间的访问必须是互斥的（通过操作系统提供的工具实现）。

    相比之下，这种共享方式速度更快，是一种高级通信方式。

- 管道通信

  管道：在内存中开辟的一个大小固定的缓冲区，是半双工的（每次只能到一个方向，因此是互斥的）。只有进程把数据都写满，另一个进程才能读；一个进程把数据读空，另一个进程才能写。

  因为数据被读出去之后就被抛弃了，所以为了确保数据的完整性，一次只能有一个进程读

- 消息传递

  操作系统向进程提供了“发送消息/接收消息”两个 **原语** 进行数据交换。进程间数据交换以 **格式化的消息** 为单位。

  消息包括：消息头、消息体；

  消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化信息（计算机网络中的报文就是一种格式化的消息）

  - 直接通信方式

    一个进程通过发送原语，把消息加到另一个进程的 **消息缓冲队列**，另一个进程通过接收原语读取消息缓冲队列。

  - 间接通信方式

    一个进程通过发送原语把消息先发送到 **中间实体** 中，另一个进程通过接收原语从中间实体读消息。

## 线程

线程是一个基本的CPU执行单元，是程序执行流的最小单位。（引入线程前是进程）

并发性：不仅进程之间可以并发，进程内的各线程也可以并发，从而进一步提升了系统的并发度，使得一个进程内可以并发处理各种任务。

系统开销：进程间切换，需要CPU在用户态和内核态间切换，也需要把PCB的状态进行修改，将进程运行状态保存到PCB中等等，系统开销很大。同一进程内的线程切换则不需要切换进程环境，系统开销小。

## 线程的组成

线程id + 线程控制块（TCB）

## 线程的通信

同一进程中的线程共享内存地址空间，故可以直接共享数据，无序系统干预

## 线程的实现方式

- 用户级线程

  通过线程库实现，所有的线程管理工作都由应用程序负责，在用户态下即可完成。

  对系统内核来说，意识不到线程的存在。

- 内核级线程

  线程管理工作由操作系统内核完成，需要在核心态下完成

  因为操作系统只看得见内核级线程，因此 **只有内核级线程才是处理机分配的单位**（会分配多少个cpu来处理）

## 多线程模型

- 多对一模型

  多个用户线程映射到一个内核级线程

  优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

  缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上运行。

- 一对一模型

  每个用户线程映射到一个内核级线程

  优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。可以在多核处理器上并行执行。

  缺点：线程间的切换由操作系统内核完成，需要切换到内核态，因此线程管理的成本高，开销大。

- 多对多模型

  上面两个模型的折中方案。

## 处理机调度

- 高级调度（作业调度）

  按照某种规则，从外存中的后备队列中选择合适的作业将其调入内存，并创建PCB，并在作业完成后作善后处理工作。

  发生频率较低

- 中级调度（内存调度）

  在内存使用情况紧张时，把一些暂时不能运行的进程从内存换到外存上等待（PCB还在内存中），加入相应挂起队列（就绪挂起队列、阻塞挂起队列），进程处于挂起态。当内存有足够空闲空间时，再将合适的进程换入内存。

  这样可以提高内存利用率和系统吞吐量。

- 低级调度（进程调度）

  根据一定算法将CPU分派给就绪队列中的一个进程，来实现CPU在进程间的切换。

  低级调度发生频率很高，在分时系统中往往几十毫秒就运行一次。

## 进程调度（低级调度）

**时机：**

1. 当前运行的进程主动放弃处理机

   如：进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞

2. 当前运行的进程被动放弃处理机

   如：分给进程的时间片用完、有更紧急的任务需要处理（中断）、有更高优先级的进程进入就绪队列

但是，1. 在处理中断的过程中，不能被切换；2. 进程在 **操作系统内核程序临界区** 中时（比如CPU对就绪队列进行操作，而访问普通的临界区可以进行调度和切换），不能被切换；3. 执行原语的进程不可被切换

临界区，可以理解为被加锁的数据结构

**调度方式：**

1. 非剥夺调度方式（非抢占方式）

   只允许进程主动放弃处理机

2. 剥夺调度方式（抢占方式）

   允许被动放弃处理机

## 调度算法评估指标

1. CPU利用率：CPU忙碌的时间占总时间的比例。

   ![image-20210409124010100](https://img.jooks.cn/img/20210409124010.png)

2. 系统吞吐量：单位时间内完成作业的数量

   ![image-20210409124247200](https://img.jooks.cn/img/20210409124247.png)

3. 周转时间：作业从提交到完成花费的时间

   ![image-20210409124425176](https://img.jooks.cn/img/20210409124425.png)

   ![image-20210409124444151](https://img.jooks.cn/img/20210409124444.png)

   ![image-20210409124835225](https://img.jooks.cn/img/20210409124835.png)

4. 等待时间：对于  **进程** 是被建立后等待被服务的时间之和（等IO不算进去）；对于 **作业** 是包括了作业在外存后备队列中的等待时间和建立进程后的等待时间。

5. 响应时间：指从用户提交请求到首次产生响应所用的时间。

## 调度算法

> 适用早期批处理系统

#### 先来先服务（FCFS）

对于作业，考虑哪个作业先到达后备队列；用于进程调度时，考虑是哪个进程先到达就绪队列。

属于非抢占式的算法

优点：公平、算法实现简单

缺点：对长作业有利，对短作业不利

不会导致饥饿

#### 短作业优先算法（SJF）

有抢占式（最短剩余时间优先算法SRTN）和非抢占式（短进程优先调度算法SPF）的短作业优先算法

抢占式就是每次有新进程到达就绪队列时，就会比较新进程的运行时间和正在执行的进程的剩余运行时间进行比较，若新进程的运行时间更短，那就进行进程的切换，否则新进程进入等待状态。

#### 高响应比优先算法（NRRN）

非抢占式

当前运行的进程主动放弃CPU时，进行调度，计算所有就绪进程的响应比，选响应比最高的进程。

不会导致饥饿。等待时间相同时，要求服务时间短的优先；要求服务时间相同时，等待时间长的优先。

> 交互式系统

#### 时间片轮转

轮流让就绪队列里的进程执行一个时间片。

是一种抢占式的算法，由时钟装置发出 **时钟中断** 来通知CPU时间片已到。

时间片太大，会退化成先来先服务调度算法；时间片太小，会导致进程切换过于频繁，系统开销大。

#### 优先级调度算法

为每个进程分配一个优先数，随时间推移优先数不断增大，防止进程饥饿。

有抢占式和非抢占式

系统进程优先级高于用户进程

前台进程优先级高于后台进程

操作系统更偏好I/O型进程

#### 多级反馈队列调度算法



## 进程互斥的软件实现方法

#### 单标志法

就是设置一个变量，若值为a，就让进程a进临界区，若值为b，就让进程b进入临界区。

#### 双标志法

设置两个变量

![image-20210410173201723](https://img.jooks.cn/img/20210410173201.png)

## 信号量

信号量就是一个变量，可以是一个整数，也可以是更复杂的记录型变量。

## 经典问题

生产者消费者

多生产者多消费者

吸烟者

读者-写者

哲学家进餐

## 管程





















