从class文件到内存中的引用类型，需要经过 **加载、链接、初始化** 三大步骤。

## 引用类型

引用类型包括：类、接口、数组类、泛型参数（在编译过程中擦除，因此这里不作讨论）。

## 字节流

类和接口有对应的字节流。

但是数组类是由jvm直接生成的，没有字节流。（new 数组会触发加载，不会触发链接、初始化）

字节流的形式包括：class文件、程序内部生成、网络中获取。

## 加载

加载，就是查找字节流，并且据此创建类的过程。

双亲委托机制：每一个类加载器接收到加载请求时，会先将请求转发给父类加载器，在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

除了启动类加载器外，其他类加载器都是java.lang.ClassLoader的子类。

从上到下为：启动类加载器 (Bootstrap Classloader)、扩展类加载器 (Extension Classloader)、应用类加载器 (Application Classloader)、自定义类加载器。

PS：在jvm中，类的唯一性是由类加载器实例和类的全名一同确定的，即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。

## 链接

链接，就是将创建成的类合并至Java虚拟机中，使之能够执行的过程。

链接可分为验证、准备、解析三个阶段。

#### 验证

暂时略。

#### 准备

为被加载类的静态字段分配内存（不包含初始化），部分jvm还会在此阶段构造其他跟类层次相关的数据结构。

#### 解析

将符号引用解析成实际引用。

如果符号引用指向未被加载的类，或者未被加载类的字段或方法，那么将触发这个类的加载（但未必触发这个类的链接、初始化）。

## 初始化

Java代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被final修饰，且类型为基本类型或字符串，那么会被编译器标记为 **常量值**，初始化直接由jvm完成。

除此之外的直接赋值操作，以及静态代码块中的代码，则会被Java编译器置于同一方法中，命名为 `<clinit>`。

初始化，就是为标记为常量值的字段赋值，以及执行 `<clinit>`方法。

jvm会通过加锁来确保`<clinit>`只执行一次，利用这个特性，可实现懒汉式单例模式。

```java
public class Singleton {
	private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
```

