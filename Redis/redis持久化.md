redis持久化有两种方式，一种是aof日志，还有一种是rdb快照。

## AOF日志

与MySQL的WAL(写前日志)不同，AOF是写后日志，即先执行命令，把数据写入内存，然后记录日志。

> **为什么要先执行命令，再写日志呢？**

首先，AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。既然是命令，肯定存在输错命令的情况。

但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。

所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。

另外，不会阻塞当前的写操作。（**但可能阻塞下一个写操作**）

> “写后日志”的风险

1. 若刚执行完命令，但还没写aof到磁盘中时，发生了宕机，那么这个命令和相应数据就会丢失。
2. 可能阻塞下一个写操作

> 写回策略（appendfsync)

![image-20210316220444890](https://img.jooks.cn/img/20210316220444.png)

> 重写机制

日志文件太大会极大影响效率，故redis有一个重写机制，即：读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。

重写的过程可以概括为：“一个拷贝，两处日志”。

一个拷贝：执行重写时，主线程fork出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程。这样子进程就可以在不影响主进程的情况下执行重写了。

第一处日志：重写过程中新的命令继续记录进原来的aof文件。

第二处日志：新的命令写进AOF重写缓存。（主线程进行）

> 重写的主动触发：手动发送“bgrewriteaof”指令。
>
> 自动触发：　　
>
> 1）auto-aof-rewrite-percentage 100
>
> 2）auto-aof-rewrite-min-size 64mb
>
> 这两个配置项的意思是，在aof文件体量超过64mb，且比上次重写后的体量增加了100%时自动触发重写。我们可以修改这些参数达到自己的实际要求。

## RDB快照

AOF有个缺点：当数据量很大时，用AOF恢复数据会很慢。而RDB是直接记录下了某个时刻内存中的数据，可以快速恢复。

> 全量快照

把内存中所有的数据都写入快照。

> 是否阻塞？

RDB快照有两种模式。

1. save：在主线程中执行，会导致阻塞；
2. bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

> bgsave快照时能写入吗？

redis借助操作系统提供的**写时复制技术**（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

如果主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本，快照进程读取这个副本即可。

> 增量快照

所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。

> 混合使用 AOF 日志和内存快照（Redis4.0）

AOF记录两次快照之间的操作，等到第二次快照时清空AOF。

这样既避免了AOF文件过大的问题，也解决了RDB间隔时间过长影响可靠性，间隔时间过短开销大的问题。

